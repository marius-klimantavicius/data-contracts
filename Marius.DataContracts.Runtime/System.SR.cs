// <auto-generated>
using System.Reflection;
 
namespace FxResources.System.Private.DataContractSerialization
{
    internal static class SR { }
}
namespace System
{
    internal static partial class SR
    {
        private static global::System.Resources.ResourceManager s_resourceManager;
        internal static global::System.Resources.ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new global::System.Resources.ResourceManager(typeof(FxResources.System.Private.DataContractSerialization.SR)));
 
        /// <summary>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</summary>
        internal static string @ArrayExceededSize => GetResourceString("ArrayExceededSize", @"Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.");
        /// <summary>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</summary>
        internal static string @ArrayExceededSizeAttribute => GetResourceString("ArrayExceededSizeAttribute", @"Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.");
        /// <summary>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</summary>
        internal static string @ArrayTypeIsNotSupported_GeneratingCode => GetResourceString("ArrayTypeIsNotSupported_GeneratingCode", @"An internal error has occurred. '{0}[]' is not supported when generating code for serialization.");
        /// <summary>Cannot deserialize since root element references unrecognized object with id '{0}'.</summary>
        internal static string @CannotDeserializeRefAtTopLevel => GetResourceString("CannotDeserializeRefAtTopLevel", @"Cannot deserialize since root element references unrecognized object with id '{0}'.");
        /// <summary>Cannot load member type '{0}'.</summary>
        internal static string @CannotLoadMemberType => GetResourceString("CannotLoadMemberType", @"Cannot load member type '{0}'.");
        /// <summary>Object graph for type '{0}' contains cycles and cannot be serialized if references are not tracked. Consider using the DataContractAttribute with the IsReference property set to true.</summary>
        internal static string @CannotSerializeObjectWithCycles => GetResourceString("CannotSerializeObjectWithCycles", @"Object graph for type '{0}' contains cycles and cannot be serialized if references are not tracked. Consider using the DataContractAttribute with the IsReference property set to true.");
        /// <summary>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</summary>
        internal static string @CanOnlyStoreIntoArgOrLocGot0 => GetResourceString("CanOnlyStoreIntoArgOrLocGot0", @"An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.");
        /// <summary>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</summary>
        internal static string @CharIsInvalidPrimitive => GetResourceString("CharIsInvalidPrimitive", @"An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.");
        /// <summary>Serialization Callback '{1}' in type '{0}' must return void.</summary>
        internal static string @CallbackMustReturnVoid => GetResourceString("CallbackMustReturnVoid", @"Serialization Callback '{1}' in type '{0}' must return void.");
        /// <summary>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</summary>
        internal static string @CallbackParameterInvalid => GetResourceString("CallbackParameterInvalid", @"Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.");
        /// <summary>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</summary>
        internal static string @CallbacksCannotBeVirtualMethods => GetResourceString("CallbacksCannotBeVirtualMethods", @"Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.");
        /// <summary>Collection type '{0}' does not have a valid Add method.</summary>
        internal static string @CollectionMustHaveAddMethod => GetResourceString("CollectionMustHaveAddMethod", @"Collection type '{0}' does not have a valid Add method.");
        /// <summary>Collection type '{0}' does not have a valid GetEnumerator method.</summary>
        internal static string @CollectionMustHaveGetEnumeratorMethod => GetResourceString("CollectionMustHaveGetEnumeratorMethod", @"Collection type '{0}' does not have a valid GetEnumerator method.");
        /// <summary>Collection type '{0}' must have a non-null item type.</summary>
        internal static string @CollectionMustHaveItemType => GetResourceString("CollectionMustHaveItemType", @"Collection type '{0}' must have a non-null item type.");
        /// <summary>{0} is a built-in type and cannot be a collection.</summary>
        internal static string @CollectionTypeCannotBeBuiltIn => GetResourceString("CollectionTypeCannotBeBuiltIn", @"{0} is a built-in type and cannot be a collection.");
        /// <summary>{0} has DataContractAttribute attribute.</summary>
        internal static string @CollectionTypeCannotHaveDataContract => GetResourceString("CollectionTypeCannotHaveDataContract", @"{0} has DataContractAttribute attribute.");
        /// <summary>{0} does not have a valid Add method with parameter of type '{1}'.</summary>
        internal static string @CollectionTypeDoesNotHaveAddMethod => GetResourceString("CollectionTypeDoesNotHaveAddMethod", @"{0} does not have a valid Add method with parameter of type '{1}'.");
        /// <summary>{0} does not have a default constructor.</summary>
        internal static string @CollectionTypeDoesNotHaveDefaultCtor => GetResourceString("CollectionTypeDoesNotHaveDefaultCtor", @"{0} does not have a default constructor.");
        /// <summary>{0} has multiple definitions of interface '{1}'.</summary>
        internal static string @CollectionTypeHasMultipleDefinitionsOfInterface => GetResourceString("CollectionTypeHasMultipleDefinitionsOfInterface", @"{0} has multiple definitions of interface '{1}'.");
        /// <summary>{0} does not implement IEnumerable interface.</summary>
        internal static string @CollectionTypeIsNotIEnumerable => GetResourceString("CollectionTypeIsNotIEnumerable", @"{0} does not implement IEnumerable interface.");
        /// <summary>An internal error has occurred. DataContract cache overflow.</summary>
        internal static string @DataContractCacheOverflow => GetResourceString("DataContractCacheOverflow", @"An internal error has occurred. DataContract cache overflow.");
        /// <summary>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</summary>
        internal static string @DataContractNamespaceAlreadySet => GetResourceString("DataContractNamespaceAlreadySet", @"ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.");
        /// <summary>DataContract namespace '{0}' is not a valid URI.</summary>
        internal static string @DataContractNamespaceIsNotValid => GetResourceString("DataContractNamespaceIsNotValid", @"DataContract namespace '{0}' is not a valid URI.");
        /// <summary>DataContract namespace '{0}' cannot be specified since it is reserved.</summary>
        internal static string @DataContractNamespaceReserved => GetResourceString("DataContractNamespaceReserved", @"DataContract namespace '{0}' cannot be specified since it is reserved.");
        /// <summary>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.</summary>
        internal static string @DataMemberOnEnumField => GetResourceString("DataMemberOnEnumField", @"Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.");
        /// <summary>Element '{2}:{3}' contains data of the '{0}:{1}' data contract. The deserializer has no knowledge of any type that maps to this contract. Add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribut ...</summary>
        internal static string @DcTypeNotFoundOnDeserialize => GetResourceString("DcTypeNotFoundOnDeserialize", @"Element '{2}:{3}' contains data of the '{0}:{1}' data contract. The deserializer has no knowledge of any type that maps to this contract. Add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to DataContractSerializer.");
        /// <summary>Type '{0}' with data contract name '{1}:{2}' is not expected. Add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializ ...</summary>
        internal static string @DcTypeNotFoundOnSerialize => GetResourceString("DcTypeNotFoundOnSerialize", @"Type '{0}' with data contract name '{1}:{2}' is not expected. Add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializer.");
        /// <summary>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-n ...</summary>
        internal static string @DcTypeNotResolvedOnDeserialize => GetResourceString("DcTypeNotResolvedOnDeserialize", @"Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.");
        /// <summary>Deserialized object with reference id '{0}' not found in stream.</summary>
        internal static string @DeserializedObjectWithIdNotFound => GetResourceString("DeserializedObjectWithIdNotFound", @"Deserialized object with reference id '{0}' not found in stream.");
        /// <summary>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present.</summary>
        internal static string @DupContractInKnownTypes => GetResourceString("DupContractInKnownTypes", @"Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present.");
        /// <summary>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</summary>
        internal static string @DupKeyValueName => GetResourceString("DupKeyValueName", @"The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.");
        /// <summary>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</summary>
        internal static string @DupEnumMemberValue => GetResourceString("DupEnumMemberValue", @"Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.");
        /// <summary>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</summary>
        internal static string @DupMemberName => GetResourceString("DupMemberName", @"Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.");
        /// <summary>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</summary>
        internal static string @DuplicateAttribute => GetResourceString("DuplicateAttribute", @"Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.");
        /// <summary>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</summary>
        internal static string @DuplicateCallback => GetResourceString("DuplicateCallback", @"Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.");
        /// <summary>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'.</summary>
        internal static string @EncounteredWithNameNamespace => GetResourceString("EncounteredWithNameNamespace", @"{0}. Encountered '{1}'  with name '{2}', namespace '{3}'.");
        /// <summary>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</summary>
        internal static string @EnumTypeCannotHaveIsReference => GetResourceString("EnumTypeCannotHaveIsReference", @"Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.");
        /// <summary>There was an error deserializing the object {0}. {1}</summary>
        internal static string @ErrorDeserializing => GetResourceString("ErrorDeserializing", @"There was an error deserializing the object {0}. {1}");
        /// <summary>Error in line {0} position {1}.</summary>
        internal static string @ErrorInLine => GetResourceString("ErrorInLine", @"Error in line {0} position {1}.");
        /// <summary>There was an error checking start element of object {0}. {1}</summary>
        internal static string @ErrorIsStartObject => GetResourceString("ErrorIsStartObject", @"There was an error checking start element of object {0}. {1}");
        /// <summary>There was an error serializing the object {0}. {1}</summary>
        internal static string @ErrorSerializing => GetResourceString("ErrorSerializing", @"There was an error serializing the object {0}. {1}");
        /// <summary>of type {0}</summary>
        internal static string @ErrorTypeInfo => GetResourceString("ErrorTypeInfo", @"of type {0}");
        /// <summary>There was an error writing end element of object {0}. {1}</summary>
        internal static string @ErrorWriteEndObject => GetResourceString("ErrorWriteEndObject", @"There was an error writing end element of object {0}. {1}");
        /// <summary>There was an error writing start element of object {0}. {1}</summary>
        internal static string @ErrorWriteStartObject => GetResourceString("ErrorWriteStartObject", @"There was an error writing start element of object {0}. {1}");
        /// <summary>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'.</summary>
        internal static string @ExceededMaxItemsQuota => GetResourceString("ExceededMaxItemsQuota", @"Maximum number of items that can be serialized or deserialized in an object graph is '{0}'.");
        /// <summary>Expecting element '{1}' from namespace '{0}'.</summary>
        internal static string @ExpectingElement => GetResourceString("ExpectingElement", @"Expecting element '{1}' from namespace '{0}'.");
        /// <summary>Expecting state '{0}' when ReadObject is called.</summary>
        internal static string @ExpectingElementAtDeserialize => GetResourceString("ExpectingElementAtDeserialize", @"Expecting state '{0}' when ReadObject is called.");
        /// <summary>Expecting End'{0}'.</summary>
        internal static string @ExpectingEnd => GetResourceString("ExpectingEnd", @"Expecting End'{0}'.");
        /// <summary>Expecting state '{0}'.</summary>
        internal static string @ExpectingState => GetResourceString("ExpectingState", @"Expecting state '{0}'.");
        /// <summary>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</summary>
        internal static string @GenericNameBraceMismatch => GetResourceString("GenericNameBraceMismatch", @"The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.");
        /// <summary>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on th ...</summary>
        internal static string @GenericParameterNotValid => GetResourceString("GenericParameterNotValid", @"In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.");
        /// <summary>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do  ...</summary>
        internal static string @InconsistentIsReference => GetResourceString("InconsistentIsReference", @"The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.");
        /// <summary>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</summary>
        internal static string @IndexedPropertyCannotBeSerialized => GetResourceString("IndexedPropertyCannotBeSerialized", @"Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.");
        /// <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</summary>
        internal static string @InvalidCollectionContractItemName => GetResourceString("InvalidCollectionContractItemName", @"Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.");
        /// <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</summary>
        internal static string @InvalidCollectionContractKeyName => GetResourceString("InvalidCollectionContractKeyName", @"Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.");
        /// <summary>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</summary>
        internal static string @InvalidCollectionContractKeyNoDictionary => GetResourceString("InvalidCollectionContractKeyNoDictionary", @"The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.");
        /// <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</summary>
        internal static string @InvalidCollectionContractName => GetResourceString("InvalidCollectionContractName", @"Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.");
        /// <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</summary>
        internal static string @InvalidCollectionContractNamespace => GetResourceString("InvalidCollectionContractNamespace", @"Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.");
        /// <summary>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</summary>
        internal static string @InvalidCollectionContractValueName => GetResourceString("InvalidCollectionContractValueName", @"Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.");
        /// <summary>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</summary>
        internal static string @InvalidCollectionContractValueNoDictionary => GetResourceString("InvalidCollectionContractValueNoDictionary", @"The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.");
        /// <summary>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</summary>
        internal static string @InvalidCollectionDataContract => GetResourceString("InvalidCollectionDataContract", @"Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it");
        /// <summary>Type '{0}' is an invalid collection type since it</summary>
        internal static string @InvalidCollectionType => GetResourceString("InvalidCollectionType", @"Type '{0}' is an invalid collection type since it");
        /// <summary>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</summary>
        internal static string @InvalidDataContractName => GetResourceString("InvalidDataContractName", @"Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.");
        /// <summary>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</summary>
        internal static string @InvalidDataContractNamespace => GetResourceString("InvalidDataContractNamespace", @"Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.");
        /// <summary>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</summary>
        internal static string @InvalidDataMemberName => GetResourceString("InvalidDataMemberName", @"Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.");
        /// <summary>'{0}' is an invalid data node when deserializing extension data.</summary>
        internal static string @InvalidDataNode => GetResourceString("InvalidDataNode", @"'{0}' is an invalid data node when deserializing extension data.");
        /// <summary>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</summary>
        internal static string @InvalidEnumBaseType => GetResourceString("InvalidEnumBaseType", @"Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.");
        /// <summary>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</summary>
        internal static string @InvalidEnumMemberValue => GetResourceString("InvalidEnumMemberValue", @"'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.");
        /// <summary>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</summary>
        internal static string @InvalidEnumValueOnRead => GetResourceString("InvalidEnumValueOnRead", @"Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.");
        /// <summary>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</summary>
        internal static string @InvalidEnumValueOnWrite => GetResourceString("InvalidEnumValueOnWrite", @"Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.");
        /// <summary>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string.</summary>
        internal static string @InvalidGetSchemaMethod => GetResourceString("InvalidGetSchemaMethod", @"Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string.");
        /// <summary>CLR namespace '{0}' cannot have ContractNamespace set to null.</summary>
        internal static string @InvalidGlobalDataContractNamespace => GetResourceString("InvalidGlobalDataContractNamespace", @"CLR namespace '{0}' cannot have ContractNamespace set to null.");
        /// <summary>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</summary>
        internal static string @InvalidMember => GetResourceString("InvalidMember", @"Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.");
        /// <summary>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny</summary>
        internal static string @InvalidNonNullReturnValueByIsAny => GetResourceString("InvalidNonNullReturnValueByIsAny", @"Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny");
        /// <summary>Type '{0}' is not a valid serializable type.</summary>
        internal static string @InvalidPrimitiveType_Serialization => GetResourceString("InvalidPrimitiveType_Serialization", @"Type '{0}' is not a valid serializable type.");
        /// <summary>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}'.</summary>
        internal static string @InvalidReturnTypeOnGetSchemaMethod => GetResourceString("InvalidReturnTypeOnGetSchemaMethod", @"Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}'.");
        /// <summary>Invalid Size '{0}'. Must be non-negative integer.</summary>
        internal static string @InvalidSizeDefinition => GetResourceString("InvalidSizeDefinition", @"Invalid Size '{0}'. Must be non-negative integer.");
        /// <summary>XML data contract Name for type '{0}' cannot be set to null or empty string.</summary>
        internal static string @InvalidXmlDataContractName => GetResourceString("InvalidXmlDataContractName", @"XML data contract Name for type '{0}' cannot be set to null or empty string.");
        /// <summary>Invalid Id '{0}'. Must not be null or empty.</summary>
        internal static string @InvalidXsIdDefinition => GetResourceString("InvalidXsIdDefinition", @"Invalid Id '{0}'. Must not be null or empty.");
        /// <summary>Invalid Ref '{0}'. Must not be null or empty.</summary>
        internal static string @InvalidXsRefDefinition => GetResourceString("InvalidXsRefDefinition", @"Invalid Ref '{0}'. Must not be null or empty.");
        /// <summary>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</summary>
        internal static string @IsAnyCannotBeNull => GetResourceString("IsAnyCannotBeNull", @"A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.");
        /// <summary>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is corre ...</summary>
        internal static string @IsAnyCannotBeSerializedAsDerivedType => GetResourceString("IsAnyCannotBeSerializedAsDerivedType", @"An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.");
        /// <summary>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</summary>
        internal static string @IsAnyCannotHaveXmlRoot => GetResourceString("IsAnyCannotHaveXmlRoot", @"Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.");
        /// <summary>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</summary>
        internal static string @IsNotAssignableFrom => GetResourceString("IsNotAssignableFrom", @"An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.");
        /// <summary>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'.</summary>
        internal static string @IsRequiredDataMemberOnIsReferenceDataContractType => GetResourceString("IsRequiredDataMemberOnIsReferenceDataContractType", @"'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'.");
        /// <summary>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</summary>
        internal static string @IXmlSerializableCannotHaveCollectionDataContract => GetResourceString("IXmlSerializableCannotHaveCollectionDataContract", @"Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.");
        /// <summary>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</summary>
        internal static string @IXmlSerializableCannotHaveDataContract => GetResourceString("IXmlSerializableCannotHaveDataContract", @"Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.");
        /// <summary>This method cannot be called from IXmlSerializable implementations.</summary>
        internal static string @IXmlSerializableIllegalOperation => GetResourceString("IXmlSerializableIllegalOperation", @"This method cannot be called from IXmlSerializable implementations.");
        /// <summary>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</summary>
        internal static string @IXmlSerializableMissingEndElements => GetResourceString("IXmlSerializableMissingEndElements", @"IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.");
        /// <summary>IXmlSerializable Type '{0}' must have default constructor.</summary>
        internal static string @IXmlSerializableMustHaveDefaultConstructor => GetResourceString("IXmlSerializableMustHaveDefaultConstructor", @"IXmlSerializable Type '{0}' must have default constructor.");
        /// <summary>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</summary>
        internal static string @IXmlSerializableWritePastSubTree => GetResourceString("IXmlSerializableWritePastSubTree", @"IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.");
        /// <summary>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</summary>
        internal static string @KnownTypeAttributeEmptyString => GetResourceString("KnownTypeAttributeEmptyString", @"Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.");
        /// <summary>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</summary>
        internal static string @KnownTypeAttributeUnknownMethod => GetResourceString("KnownTypeAttributeUnknownMethod", @"KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.");
        /// <summary>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</summary>
        internal static string @KnownTypeAttributeReturnType => GetResourceString("KnownTypeAttributeReturnType", @"KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable<Type>. Ensure that the method exists and has a valid signature.");
        /// <summary>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</summary>
        internal static string @KnownTypeAttributeOneScheme => GetResourceString("KnownTypeAttributeOneScheme", @"Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.");
        /// <summary>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</summary>
        internal static string @KnownTypeAttributeValidMethodTypes => GetResourceString("KnownTypeAttributeValidMethodTypes", @"Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.");
        /// <summary>KnownTypeAttribute attribute on type '{0}' contains no data.</summary>
        internal static string @KnownTypeAttributeNoData => GetResourceString("KnownTypeAttributeNoData", @"KnownTypeAttribute attribute on type '{0}' contains no data.");
        /// <summary>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</summary>
        internal static string @KnownTypeAttributeMethodNull => GetResourceString("KnownTypeAttributeMethodNull", @"Method specified by KnownTypeAttribute attribute on type '{0}' returned null.");
        /// <summary>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'.</summary>
        internal static string @MaxArrayLengthExceeded => GetResourceString("MaxArrayLengthExceeded", @"The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'.");
        /// <summary>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</summary>
        internal static string @MissingGetSchemaMethod => GetResourceString("MissingGetSchemaMethod", @"Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.");
        /// <summary>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</summary>
        internal static string @MultipleIdDefinition => GetResourceString("MultipleIdDefinition", @"Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.");
        /// <summary>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</summary>
        internal static string @NoConversionPossibleTo => GetResourceString("NoConversionPossibleTo", @"An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.");
        /// <summary>No get method for property '{1}' in type '{0}'.</summary>
        internal static string @NoGetMethodForProperty => GetResourceString("NoGetMethodForProperty", @"No get method for property '{1}' in type '{0}'.");
        /// <summary>No set method for property '{1}' in type '{0}'.</summary>
        internal static string @NoSetMethodForProperty => GetResourceString("NoSetMethodForProperty", @"No set method for property '{1}' in type '{0}'.");
        /// <summary>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</summary>
        internal static string @NullKnownType => GetResourceString("NullKnownType", @"One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.");
        /// <summary>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection either in the constructor of the object or in the getter.</summary>
        internal static string @NullValueReturnedForGetOnlyCollection => GetResourceString("NullValueReturnedForGetOnlyCollection", @"The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection either in the constructor of the object or in the getter.");
        /// <summary>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</summary>
        internal static string @ObjectTableOverflow => GetResourceString("ObjectTableOverflow", @"An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.");
        /// <summary>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</summary>
        internal static string @ParameterCountMismatch => GetResourceString("ParameterCountMismatch", @"Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.");
        /// <summary>The collection data contract type '{0}' cannot be deserialized because the method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly ...</summary>
        internal static string @PartialTrustCollectionContractAddMethodNotPublic => GetResourceString("PartialTrustCollectionContractAddMethodNotPublic", @"The collection data contract type '{0}' cannot be deserialized because the method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The collection data contract type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisible ...</summary>
        internal static string @PartialTrustCollectionContractNoPublicConstructor => GetResourceString("PartialTrustCollectionContractNoPublicConstructor", @"The collection data contract type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The collection data contract type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisible ...</summary>
        internal static string @PartialTrustCollectionContractTypeNotPublic => GetResourceString("PartialTrustCollectionContractTypeNotPublic", @"The collection data contract type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be serialized because the OnSerializing method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembl ...</summary>
        internal static string @PartialTrustDataContractOnSerializingNotPublic => GetResourceString("PartialTrustDataContractOnSerializingNotPublic", @"The data contract type '{0}' cannot be serialized because the OnSerializing method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be serialized because the OnSerialized method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly ...</summary>
        internal static string @PartialTrustDataContractOnSerializedNotPublic => GetResourceString("PartialTrustDataContractOnSerializedNotPublic", @"The data contract type '{0}' cannot be serialized because the OnSerialized method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the OnDeserializing method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your ass ...</summary>
        internal static string @PartialTrustDataContractOnDeserializingNotPublic => GetResourceString("PartialTrustDataContractOnDeserializingNotPublic", @"The data contract type '{0}' cannot be deserialized because the OnDeserializing method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the OnDeserialized method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your asse ...</summary>
        internal static string @PartialTrustDataContractOnDeserializedNotPublic => GetResourceString("PartialTrustDataContractOnDeserializedNotPublic", @"The data contract type '{0}' cannot be deserialized because the OnDeserialized method '{1}' is not public. Making the method public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to  ...</summary>
        internal static string @PartialTrustDataContractFieldGetNotPublic => GetResourceString("PartialTrustDataContractFieldGetNotPublic", @"The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order t ...</summary>
        internal static string @PartialTrustDataContractFieldSetNotPublic => GetResourceString("PartialTrustDataContractFieldSetNotPublic", @"The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be serialized because the property '{1}' does not have a public getter. Adding a public getter will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assem ...</summary>
        internal static string @PartialTrustDataContractPropertyGetNotPublic => GetResourceString("PartialTrustDataContractPropertyGetNotPublic", @"The data contract type '{0}' cannot be serialized because the property '{1}' does not have a public getter. Adding a public getter will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the property '{1}' does not have a public setter. Adding a public setter will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your ass ...</summary>
        internal static string @PartialTrustDataContractPropertySetNotPublic => GetResourceString("PartialTrustDataContractPropertySetNotPublic", @"The data contract type '{0}' cannot be deserialized because the property '{1}' does not have a public setter. Adding a public setter will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The data contract type '{0}' is not serializable because it is not public. Making the type public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serializat ...</summary>
        internal static string @PartialTrustDataContractTypeNotPublic => GetResourceString("PartialTrustDataContractTypeNotPublic", @"The data contract type '{0}' is not serializable because it is not public. Making the type public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal memb ...</summary>
        internal static string @PartialTrustNonAttributedSerializableTypeNoPublicConstructor => GetResourceString("PartialTrustNonAttributedSerializableTypeNoPublicConstructor", @"The type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your ...</summary>
        internal static string @PartialTrustIXmlSerializableTypeNotPublic => GetResourceString("PartialTrustIXmlSerializableTypeNotPublic", @"The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The IXmlSerializable type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttrib ...</summary>
        internal static string @PartialTrustIXmlSerialzableNoPublicConstructor => GetResourceString("PartialTrustIXmlSerialzableNoPublicConstructor", @"The IXmlSerializable type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.");
        /// <summary>The Type '{0}' must have a parameterless constructor.</summary>
        internal static string @NonAttributedSerializableTypesMustHaveDefaultConstructor => GetResourceString("NonAttributedSerializableTypesMustHaveDefaultConstructor", @"The Type '{0}' must have a parameterless constructor.");
        /// <summary>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</summary>
        internal static string @AttributedTypesCannotInheritFromNonAttributedSerializableTypes => GetResourceString("AttributedTypesCannotInheritFromNonAttributedSerializableTypes", @"Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.");
        /// <summary>The '{0}' quota is readonly.</summary>
        internal static string @QuotaIsReadOnly => GetResourceString("QuotaIsReadOnly", @"The '{0}' quota is readonly.");
        /// <summary>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</summary>
        internal static string @QuotaCopyReadOnly => GetResourceString("QuotaCopyReadOnly", @"Cannot copy XmlDictionaryReaderQuotas. Target is readonly.");
        /// <summary>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', ...</summary>
        internal static string @RequiredMemberMustBeEmitted => GetResourceString("RequiredMemberMustBeEmitted", @"Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.");
        /// <summary>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation t ...</summary>
        internal static string @ResolveTypeReturnedFalse => GetResourceString("ResolveTypeReturnedFalse", @"An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.");
        /// <summary>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation  ...</summary>
        internal static string @ResolveTypeReturnedNull => GetResourceString("ResolveTypeReturnedNull", @"An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.");
        /// <summary>Multi-dimensional arrays are not supported.</summary>
        internal static string @SupportForMultidimensionalArraysNotPresent => GetResourceString("SupportForMultidimensionalArraysNotPresent", @"Multi-dimensional arrays are not supported.");
        /// <summary>Type '{0}' has more than one CollectionDataContractAttribute attribute.</summary>
        internal static string @TooManyCollectionContracts => GetResourceString("TooManyCollectionContracts", @"Type '{0}' has more than one CollectionDataContractAttribute attribute.");
        /// <summary>Type '{0}' has more than one DataContractAttribute attribute.</summary>
        internal static string @TooManyDataContracts => GetResourceString("TooManyDataContracts", @"Type '{0}' has more than one DataContractAttribute attribute.");
        /// <summary>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</summary>
        internal static string @TooManyDataMembers => GetResourceString("TooManyDataMembers", @"Member '{0}.{1}' has more than one DataMemberAttribute attribute.");
        /// <summary>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</summary>
        internal static string @TooManyEnumMembers => GetResourceString("TooManyEnumMembers", @"Member '{0}.{1}' has more than one EnumMemberAttribute attribute.");
        /// <summary>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</summary>
        internal static string @TooManyIgnoreDataMemberAttributes => GetResourceString("TooManyIgnoreDataMemberAttributes", @"Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.");
        /// <summary>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute. Alternatively, you can ensure that the type is public and has a parame ...</summary>
        internal static string @TypeNotSerializable => GetResourceString("TypeNotSerializable", @"Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute. Alternatively, you can ensure that the type is public and has a parameterless constructor - all public members of the type will then be serialized, and no attributes will be required.");
        /// <summary>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered.</summary>
        internal static string @UnexpectedContractType => GetResourceString("UnexpectedContractType", @"An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered.");
        /// <summary>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</summary>
        internal static string @UnexpectedElementExpectingElements => GetResourceString("UnexpectedElementExpectingElements", @"'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.");
        /// <summary>Unexpected end of file.</summary>
        internal static string @UnexpectedEndOfFile => GetResourceString("UnexpectedEndOfFile", @"Unexpected end of file.");
        /// <summary>Internal Error: Unrecognized constant type {0}.</summary>
        internal static string @UnknownConstantType => GetResourceString("UnknownConstantType", @"Internal Error: Unrecognized constant type {0}.");
        /// <summary>ValueType '{0}' cannot be null.</summary>
        internal static string @ValueTypeCannotBeNull => GetResourceString("ValueTypeCannotBeNull", @"ValueType '{0}' cannot be null.");
        /// <summary>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</summary>
        internal static string @ValueTypeCannotHaveBaseType => GetResourceString("ValueTypeCannotHaveBaseType", @"Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.");
        /// <summary>ValueType '{0}' cannot have id.</summary>
        internal static string @ValueTypeCannotHaveId => GetResourceString("ValueTypeCannotHaveId", @"ValueType '{0}' cannot have id.");
        /// <summary>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</summary>
        internal static string @ValueTypeCannotHaveIsReference => GetResourceString("ValueTypeCannotHaveIsReference", @"Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.");
        /// <summary>ValueType '{0}' cannot have ref to another object.</summary>
        internal static string @ValueTypeCannotHaveRef => GetResourceString("ValueTypeCannotHaveRef", @"ValueType '{0}' cannot have ref to another object.");
        /// <summary>Only Element nodes have attributes.</summary>
        internal static string @XmlElementAttributes => GetResourceString("XmlElementAttributes", @"Only Element nodes have attributes.");
        /// <summary>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XElement to deserialize this pattern of XML.</summary>
        internal static string @XmlForObjectCannotHaveContent => GetResourceString("XmlForObjectCannotHaveContent", @"Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XElement to deserialize this pattern of XML.");
        /// <summary>The value '{0}' cannot be parsed as the type '{1}'.</summary>
        internal static string @XmlInvalidConversion => GetResourceString("XmlInvalidConversion", @"The value '{0}' cannot be parsed as the type '{1}'.");
        /// <summary>The value cannot be parsed as the type '{0}'.</summary>
        internal static string @XmlInvalidConversionWithoutValue => GetResourceString("XmlInvalidConversionWithoutValue", @"The value cannot be parsed as the type '{0}'.");
        /// <summary>Start element expected. Found {0}.</summary>
        internal static string @XmlStartElementExpected => GetResourceString("XmlStartElementExpected", @"Start element expected. Found {0}.");
        /// <summary>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</summary>
        internal static string @XmlWriterMustBeInElement => GetResourceString("XmlWriterMustBeInElement", @"WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.");
        /// <summary>{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on I ...</summary>
        internal static string @NonOptionalFieldMemberOnIsReferenceSerializableType => GetResourceString("NonOptionalFieldMemberOnIsReferenceSerializableType", @"{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.");
        /// <summary>The specified offset exceeds the buffer size ({0} bytes).</summary>
        internal static string @OffsetExceedsBufferSize => GetResourceString("OffsetExceedsBufferSize", @"The specified offset exceeds the buffer size ({0} bytes).");
        /// <summary>The specified size exceeds the remaining buffer space ({0} bytes).</summary>
        internal static string @SizeExceedsRemainingBufferSpace => GetResourceString("SizeExceedsRemainingBufferSpace", @"The specified size exceeds the remaining buffer space ({0} bytes).");
        /// <summary>The value of this argument must fall within the range {0} to {1}.</summary>
        internal static string @ValueMustBeInRange => GetResourceString("ValueMustBeInRange", @"The value of this argument must fall within the range {0} to {1}.");
        /// <summary>Array too small.  Must be able to hold at least {0}.</summary>
        internal static string @XmlArrayTooSmallOutput => GetResourceString("XmlArrayTooSmallOutput", @"Array too small.  Must be able to hold at least {0}.");
        /// <summary>An asynchronous operation is already in progress.</summary>
        internal static string @XmlAsyncIsRunningException => GetResourceString("XmlAsyncIsRunningException", @"An asynchronous operation is already in progress.");
        /// <summary>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</summary>
        internal static string @XmlInvalidBase64Length => GetResourceString("XmlInvalidBase64Length", @"Base64 sequence length ({0}) not valid. Must be a multiple of 4.");
        /// <summary>The characters '{0}' at offset {1} are not a valid Base64 sequence.</summary>
        internal static string @XmlInvalidBase64Sequence => GetResourceString("XmlInvalidBase64Sequence", @"The characters '{0}' at offset {1} are not a valid Base64 sequence.");
        /// <summary>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</summary>
        internal static string @XmlInvalidBinHexLength => GetResourceString("XmlInvalidBinHexLength", @"BinHex sequence length ({0}) not valid. Must be a multiple of 2.");
        /// <summary>The characters '{0}' at offset {1} are not a valid BinHex sequence.</summary>
        internal static string @XmlInvalidBinHexSequence => GetResourceString("XmlInvalidBinHexSequence", @"The characters '{0}' at offset {1} are not a valid BinHex sequence.");
        /// <summary>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</summary>
        internal static string @XmlInvalidHighSurrogate => GetResourceString("XmlInvalidHighSurrogate", @"High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.");
        /// <summary>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</summary>
        internal static string @XmlInvalidLowSurrogate => GetResourceString("XmlInvalidLowSurrogate", @"Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.");
        /// <summary>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</summary>
        internal static string @XmlInvalidSurrogate => GetResourceString("XmlInvalidSurrogate", @"Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.");
        /// <summary>The empty string is not a valid local name.</summary>
        internal static string @InvalidLocalNameEmpty => GetResourceString("InvalidLocalNameEmpty", @"The empty string is not a valid local name.");
        /// <summary>Array too small.</summary>
        internal static string @XmlArrayTooSmall => GetResourceString("XmlArrayTooSmall", @"Array too small.");
        /// <summary>Array too small.  Length of available data must be at least {0}.</summary>
        internal static string @XmlArrayTooSmallInput => GetResourceString("XmlArrayTooSmallInput", @"Array too small.  Length of available data must be at least {0}.");
        /// <summary>Unrecognized Byte Order Mark.</summary>
        internal static string @XmlBadBOM => GetResourceString("XmlBadBOM", @"Unrecognized Byte Order Mark.");
        /// <summary>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and ...</summary>
        internal static string @XmlMaxNameTableCharCountExceeded => GetResourceString("XmlMaxNameTableCharCountExceeded", @"The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.");
        /// <summary>Base64 encoded data expected. Found {0}.</summary>
        internal static string @XmlBase64DataExpected => GetResourceString("XmlBase64DataExpected", @"Base64 encoded data expected. Found {0}.");
        /// <summary>CData elements not valid at top level of an XML document.</summary>
        internal static string @XmlCDATAInvalidAtTopLevel => GetResourceString("XmlCDATAInvalidAtTopLevel", @"CData elements not valid at top level of an XML document.");
        /// <summary>']]&gt;' not valid in text node content.</summary>
        internal static string @XmlCloseCData => GetResourceString("XmlCloseCData", @"']]>' not valid in text node content.");
        /// <summary>The value '{0}' cannot be represented with the type '{1}'.</summary>
        internal static string @XmlConversionOverflow => GetResourceString("XmlConversionOverflow", @"The value '{0}' cannot be represented with the type '{1}'.");
        /// <summary>An XML declaration with an encoding is required for all non UTF-8 documents.</summary>
        internal static string @XmlDeclarationRequired => GetResourceString("XmlDeclarationRequired", @"An XML declaration with an encoding is required for all non UTF-8 documents.");
        /// <summary>Version not found in XML declaration.</summary>
        internal static string @XmlDeclMissingVersion => GetResourceString("XmlDeclMissingVersion", @"Version not found in XML declaration.");
        /// <summary>An XML declaration is required for all non UTF-8 documents.</summary>
        internal static string @XmlDeclMissing => GetResourceString("XmlDeclMissing", @"An XML declaration is required for all non UTF-8 documents.");
        /// <summary>No characters can appear before the XML declaration.</summary>
        internal static string @XmlDeclNotFirst => GetResourceString("XmlDeclNotFirst", @"No characters can appear before the XML declaration.");
        /// <summary>XmlDictionaryString IDs must be in the range from {0} to {1}.</summary>
        internal static string @XmlDictionaryStringIDRange => GetResourceString("XmlDictionaryStringIDRange", @"XmlDictionaryString IDs must be in the range from {0} to {1}.");
        /// <summary>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</summary>
        internal static string @XmlDictionaryStringIDUndefinedSession => GetResourceString("XmlDictionaryStringIDUndefinedSession", @"XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.");
        /// <summary>XmlDictionaryString ID {0} not defined in the static dictionary.</summary>
        internal static string @XmlDictionaryStringIDUndefinedStatic => GetResourceString("XmlDictionaryStringIDUndefinedStatic", @"XmlDictionaryString ID {0} not defined in the static dictionary.");
        /// <summary>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</summary>
        internal static string @XmlDuplicateAttribute => GetResourceString("XmlDuplicateAttribute", @"Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.");
        /// <summary>The empty namespace requires a null or empty prefix.</summary>
        internal static string @XmlEmptyNamespaceRequiresNullPrefix => GetResourceString("XmlEmptyNamespaceRequiresNullPrefix", @"The empty namespace requires a null or empty prefix.");
        /// <summary>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</summary>
        internal static string @XmlEncodingMismatch => GetResourceString("XmlEncodingMismatch", @"The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.");
        /// <summary>XML encoding not supported.</summary>
        internal static string @XmlEncodingNotSupported => GetResourceString("XmlEncodingNotSupported", @"XML encoding not supported.");
        /// <summary>End element '{0}' from namespace '{1}' expected. Found {2}.</summary>
        internal static string @XmlEndElementExpected => GetResourceString("XmlEndElementExpected", @"End element '{0}' from namespace '{1}' expected. Found {2}.");
        /// <summary>No corresponding start element is open.</summary>
        internal static string @XmlEndElementNoOpenNodes => GetResourceString("XmlEndElementNoOpenNodes", @"No corresponding start element is open.");
        /// <summary>The expected encoding '{0}' does not match the actual encoding '{1}'.</summary>
        internal static string @XmlExpectedEncoding => GetResourceString("XmlExpectedEncoding", @"The expected encoding '{0}' does not match the actual encoding '{1}'.");
        /// <summary>cdata '{0}'</summary>
        internal static string @XmlFoundCData => GetResourceString("XmlFoundCData", @"cdata '{0}'");
        /// <summary>comment '{0}'</summary>
        internal static string @XmlFoundComment => GetResourceString("XmlFoundComment", @"comment '{0}'");
        /// <summary>element '{0}' from namespace '{1}'</summary>
        internal static string @XmlFoundElement => GetResourceString("XmlFoundElement", @"element '{0}' from namespace '{1}'");
        /// <summary>end element '{0}' from namespace '{1}'</summary>
        internal static string @XmlFoundEndElement => GetResourceString("XmlFoundEndElement", @"end element '{0}' from namespace '{1}'");
        /// <summary>end of file</summary>
        internal static string @XmlFoundEndOfFile => GetResourceString("XmlFoundEndOfFile", @"end of file");
        /// <summary>node {0}</summary>
        internal static string @XmlFoundNodeType => GetResourceString("XmlFoundNodeType", @"node {0}");
        /// <summary>text '{0}'</summary>
        internal static string @XmlFoundText => GetResourceString("XmlFoundText", @"text '{0}'");
        /// <summary>Non-empty start element expected. Found {0}.</summary>
        internal static string @XmlFullStartElementExpected => GetResourceString("XmlFullStartElementExpected", @"Non-empty start element expected. Found {0}.");
        /// <summary>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</summary>
        internal static string @XmlFullStartElementLocalNameNsExpected => GetResourceString("XmlFullStartElementLocalNameNsExpected", @"Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.");
        /// <summary>Non-empty start element '{0}' expected. Found {1}.</summary>
        internal static string @XmlFullStartElementNameExpected => GetResourceString("XmlFullStartElementNameExpected", @"Non-empty start element '{0}' expected. Found {1}.");
        /// <summary>ID already defined.</summary>
        internal static string @XmlIDDefined => GetResourceString("XmlIDDefined", @"ID already defined.");
        /// <summary>The specified key already exists in the dictionary.</summary>
        internal static string @XmlKeyAlreadyExists => GetResourceString("XmlKeyAlreadyExists", @"The specified key already exists in the dictionary.");
        /// <summary>Text cannot be written outside the root element.</summary>
        internal static string @XmlIllegalOutsideRoot => GetResourceString("XmlIllegalOutsideRoot", @"Text cannot be written outside the root element.");
        /// <summary>Invalid byte encoding.</summary>
        internal static string @XmlInvalidBytes => GetResourceString("XmlInvalidBytes", @"Invalid byte encoding.");
        /// <summary>Character reference not valid.</summary>
        internal static string @XmlInvalidCharRef => GetResourceString("XmlInvalidCharRef", @"Character reference not valid.");
        /// <summary>XML comments cannot contain '--' or end with '-'.</summary>
        internal static string @XmlInvalidCommentChars => GetResourceString("XmlInvalidCommentChars", @"XML comments cannot contain '--' or end with '-'.");
        /// <summary>XML declaration can only be written at the beginning of the document.</summary>
        internal static string @XmlInvalidDeclaration => GetResourceString("XmlInvalidDeclaration", @"XML declaration can only be written at the beginning of the document.");
        /// <summary>Cannot call '{0}' while Depth is '{1}'.</summary>
        internal static string @XmlInvalidDepth => GetResourceString("XmlInvalidDepth", @"Cannot call '{0}' while Depth is '{1}'.");
        /// <summary>XML encoding must be 'UTF-8'.</summary>
        internal static string @XmlInvalidEncoding_UTF8 => GetResourceString("XmlInvalidEncoding_UTF8", @"XML encoding must be 'UTF-8'.");
        /// <summary>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</summary>
        internal static string @XmlInvalidFFFE => GetResourceString("XmlInvalidFFFE", @"Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.");
        /// <summary>The input source is not correctly formatted.</summary>
        internal static string @XmlInvalidFormat => GetResourceString("XmlInvalidFormat", @"The input source is not correctly formatted.");
        /// <summary>ID must be &gt;</summary>
        internal static string @XmlInvalidID => GetResourceString("XmlInvalidID", @"ID must be >");
        /// <summary>The reader cannot be advanced.</summary>
        internal static string @XmlInvalidOperation => GetResourceString("XmlInvalidOperation", @"The reader cannot be advanced.");
        /// <summary>A prefix cannot be defined while WriteState is '{0}'.</summary>
        internal static string @XmlInvalidPrefixState => GetResourceString("XmlInvalidPrefixState", @"A prefix cannot be defined while WriteState is '{0}'.");
        /// <summary>Expected XML qualified name. Found '{0}'.</summary>
        internal static string @XmlInvalidQualifiedName => GetResourceString("XmlInvalidQualifiedName", @"Expected XML qualified name. Found '{0}'.");
        /// <summary>The data at the root level is invalid.</summary>
        internal static string @XmlInvalidRootData => GetResourceString("XmlInvalidRootData", @"The data at the root level is invalid.");
        /// <summary>'standalone' value in declaration must be 'yes' or 'no'.</summary>
        internal static string @XmlInvalidStandalone => GetResourceString("XmlInvalidStandalone", @"'standalone' value in declaration must be 'yes' or 'no'.");
        /// <summary>UniqueId cannot be zero length.</summary>
        internal static string @XmlInvalidUniqueId => GetResourceString("XmlInvalidUniqueId", @"UniqueId cannot be zero length.");
        /// <summary>'{0}' contains invalid UTF-8 bytes.</summary>
        internal static string @XmlInvalidUTF8Bytes => GetResourceString("XmlInvalidUTF8Bytes", @"'{0}' contains invalid UTF-8 bytes.");
        /// <summary>XML version must be '1.0'.</summary>
        internal static string @XmlInvalidVersion => GetResourceString("XmlInvalidVersion", @"XML version must be '1.0'.");
        /// <summary>'{0}' cannot be called while WriteState is '{1}'.</summary>
        internal static string @XmlInvalidWriteState => GetResourceString("XmlInvalidWriteState", @"'{0}' cannot be called while WriteState is '{1}'.");
        /// <summary>The byte 0x{0} is not valid at this location.</summary>
        internal static string @XmlInvalidXmlByte => GetResourceString("XmlInvalidXmlByte", @"The byte 0x{0} is not valid at this location.");
        /// <summary>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</summary>
        internal static string @XmlInvalidXmlSpace => GetResourceString("XmlInvalidXmlSpace", @"'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.");
        /// <summary>Line {0}, position {1}.</summary>
        internal static string @XmlLineInfo => GetResourceString("XmlLineInfo", @"Line {0}, position {1}.");
        /// <summary>Malformed XML declaration.</summary>
        internal static string @XmlMalformedDecl => GetResourceString("XmlMalformedDecl", @"Malformed XML declaration.");
        /// <summary>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</summary>
        internal static string @XmlMaxArrayLengthExceeded => GetResourceString("XmlMaxArrayLengthExceeded", @"The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.");
        /// <summary>The maximum array length quota ({0}) or the maximum items in object graph quota has been exceeded while reading XML data. These quotas may be increased by changing the MaxArrayLength property on XmlDictionaryReaderQuotas or the MaxItemsInObjectGraph settin ...</summary>
        internal static string @XmlMaxArrayLengthOrMaxItemsQuotaExceeded => GetResourceString("XmlMaxArrayLengthOrMaxItemsQuotaExceeded", @"The maximum array length quota ({0}) or the maximum items in object graph quota has been exceeded while reading XML data. These quotas may be increased by changing the MaxArrayLength property on XmlDictionaryReaderQuotas or the MaxItemsInObjectGraph setting.");
        /// <summary>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the  ...</summary>
        internal static string @XmlMaxBytesPerReadExceeded => GetResourceString("XmlMaxBytesPerReadExceeded", @"The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.");
        /// <summary>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the ...</summary>
        internal static string @XmlMaxDepthExceeded => GetResourceString("XmlMaxDepthExceeded", @"The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.");
        /// <summary>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</summary>
        internal static string @XmlMaxStringContentLengthExceeded => GetResourceString("XmlMaxStringContentLengthExceeded", @"The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.");
        /// <summary>This XmlWriter implementation does not support the '{0}' method.</summary>
        internal static string @XmlMethodNotSupported => GetResourceString("XmlMethodNotSupported", @"This XmlWriter implementation does not support the '{0}' method.");
        /// <summary>The surrogate pair is invalid. Missing a low surrogate character.</summary>
        internal static string @XmlMissingLowSurrogate => GetResourceString("XmlMissingLowSurrogate", @"The surrogate pair is invalid. Missing a low surrogate character.");
        /// <summary>There are multiple root elements.</summary>
        internal static string @XmlMultipleRootElements => GetResourceString("XmlMultipleRootElements", @"There are multiple root elements.");
        /// <summary>The namespace '{0}' is not defined.</summary>
        internal static string @XmlNamespaceNotFound => GetResourceString("XmlNamespaceNotFound", @"The namespace '{0}' is not defined.");
        /// <summary>Nested arrays are not supported.</summary>
        internal static string @XmlNestedArraysNotSupported => GetResourceString("XmlNestedArraysNotSupported", @"Nested arrays are not supported.");
        /// <summary>The document does not have a root element.</summary>
        internal static string @XmlNoRootElement => GetResourceString("XmlNoRootElement", @"The document does not have a root element.");
        /// <summary>Only one root element is permitted per document.</summary>
        internal static string @XmlOnlyOneRoot => GetResourceString("XmlOnlyOneRoot", @"Only one root element is permitted per document.");
        /// <summary>Only whitespace characters can be written with this method.</summary>
        internal static string @XmlOnlyWhitespace => GetResourceString("XmlOnlyWhitespace", @"Only whitespace characters can be written with this method.");
        /// <summary>Only a single typed value may be written inside an attribute or content.</summary>
        internal static string @XmlOnlySingleValue => GetResourceString("XmlOnlySingleValue", @"Only a single typed value may be written inside an attribute or content.");
        /// <summary>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</summary>
        internal static string @XmlPrefixBoundToNamespace => GetResourceString("XmlPrefixBoundToNamespace", @"The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.");
        /// <summary>Processing instructions (other than the XML declaration) and DTDs are not supported.</summary>
        internal static string @XmlProcessingInstructionNotSupported => GetResourceString("XmlProcessingInstructionNotSupported", @"Processing instructions (other than the XML declaration) and DTDs are not supported.");
        /// <summary>Prefixes beginning with 'xml' (regardless of casing) are reserved for use by XML.</summary>
        internal static string @XmlReservedPrefix => GetResourceString("XmlReservedPrefix", @"Prefixes beginning with 'xml' (regardless of casing) are reserved for use by XML.");
        /// <summary>Whitespace must appear between attributes.</summary>
        internal static string @XmlSpaceBetweenAttributes => GetResourceString("XmlSpaceBetweenAttributes", @"Whitespace must appear between attributes.");
        /// <summary>The namespace '{1}' can only be bound to the prefix '{0}'.</summary>
        internal static string @XmlSpecificBindingNamespace => GetResourceString("XmlSpecificBindingNamespace", @"The namespace '{1}' can only be bound to the prefix '{0}'.");
        /// <summary>The prefix '{0}' can only be bound to the namespace '{1}'.</summary>
        internal static string @XmlSpecificBindingPrefix => GetResourceString("XmlSpecificBindingPrefix", @"The prefix '{0}' can only be bound to the namespace '{1}'.");
        /// <summary>Start element '{0}' from namespace '{1}' expected. Found {2}.</summary>
        internal static string @XmlStartElementLocalNameNsExpected => GetResourceString("XmlStartElementLocalNameNsExpected", @"Start element '{0}' from namespace '{1}' expected. Found {2}.");
        /// <summary>Start element '{0}' expected. Found {1}.</summary>
        internal static string @XmlStartElementNameExpected => GetResourceString("XmlStartElementNameExpected", @"Start element '{0}' expected. Found {1}.");
        /// <summary>Start element '{0}' does not match end element '{1}'.</summary>
        internal static string @XmlTagMismatch => GetResourceString("XmlTagMismatch", @"Start element '{0}' does not match end element '{1}'.");
        /// <summary>The token '{0}' was expected but found '{1}'.</summary>
        internal static string @XmlTokenExpected => GetResourceString("XmlTokenExpected", @"The token '{0}' was expected but found '{1}'.");
        /// <summary>The prefix '{0}' is not defined.</summary>
        internal static string @XmlUndefinedPrefix => GetResourceString("XmlUndefinedPrefix", @"The prefix '{0}' is not defined.");
        /// <summary>No matching start tag for end element.</summary>
        internal static string @XmlUnexpectedEndElement => GetResourceString("XmlUnexpectedEndElement", @"No matching start tag for end element.");
        /// <summary>Unexpected end of file. Following elements are not closed: {0}.</summary>
        internal static string @XmlUnexpectedEndOfFile => GetResourceString("XmlUnexpectedEndOfFile", @"Unexpected end of file. Following elements are not closed: {0}.");
        /// <summary>The XmlWriter is closed.</summary>
        internal static string @XmlWriterClosed => GetResourceString("XmlWriterClosed", @"The XmlWriter is closed.");
        /// <summary>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</summary>
        internal static string @XmlObjectAssignedToIncompatibleInterface => GetResourceString("XmlObjectAssignedToIncompatibleInterface", @"'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)");
        /// <summary>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</summary>
        internal static string @CollectionAssignedToIncompatibleInterface => GetResourceString("CollectionAssignedToIncompatibleInterface", @"'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)");
        /// <summary>Invalid byte encoding.</summary>
        internal static string @JsonInvalidBytes => GetResourceString("JsonInvalidBytes", @"Invalid byte encoding.");
        /// <summary>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</summary>
        internal static string @JsonDuplicateMemberNames => GetResourceString("JsonDuplicateMemberNames", @"The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.");
        /// <summary>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting  ...</summary>
        internal static string @JsonUnsupportedForIsReference => GetResourceString("JsonUnsupportedForIsReference", @"The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.");
        /// <summary>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</summary>
        internal static string @SerializationCodeIsMissingForType => GetResourceString("SerializationCodeIsMissingForType", @"Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.");
        /// <summary>The XML encountered when deserializing extension data is invalid.</summary>
        internal static string @InvalidXmlDeserializingExtensionData => GetResourceString("InvalidXmlDeserializingExtensionData", @"The XML encountered when deserializing extension data is invalid.");
        /// <summary>An internal error has occurred. ExtensionDataReader is in an invalid state.</summary>
        internal static string @InvalidStateInExtensionDataReader => GetResourceString("InvalidStateInExtensionDataReader", @"An internal error has occurred. ExtensionDataReader is in an invalid state.");
        /// <summary>DataContractJsonSerializer does not support objects of type '{0}'.</summary>
        internal static string @JsonTypeNotSupportedByDataContractJsonSerializer => GetResourceString("JsonTypeNotSupportedByDataContractJsonSerializer", @"DataContractJsonSerializer does not support objects of type '{0}'.");
        /// <summary>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</summary>
        internal static string @GetOnlyCollectionMustHaveAddMethod => GetResourceString("GetOnlyCollectionMustHaveAddMethod", @"Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection<T>.");
        /// <summary>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</summary>
        internal static string @JsonUnexpectedAttributeValue => GetResourceString("JsonUnexpectedAttributeValue", @"The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'");
        /// <summary>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</summary>
        internal static string @JsonInvalidDateTimeString => GetResourceString("JsonInvalidDateTimeString", @"DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.");
        /// <summary>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</summary>
        internal static string @GenericCallbackException => GetResourceString("GenericCallbackException", @"A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.");
        /// <summary>Encountered unexpected character '{0}'.</summary>
        internal static string @JsonEncounteredUnexpectedCharacter => GetResourceString("JsonEncounteredUnexpectedCharacter", @"Encountered unexpected character '{0}'.");
        /// <summary>The specified offset exceeds the buffer size ({0} bytes).</summary>
        internal static string @JsonOffsetExceedsBufferSize => GetResourceString("JsonOffsetExceedsBufferSize", @"The specified offset exceeds the buffer size ({0} bytes).");
        /// <summary>The specified size exceeds the remaining buffer space ('{0}' bytes).</summary>
        internal static string @JsonSizeExceedsRemainingBufferSpace => GetResourceString("JsonSizeExceedsRemainingBufferSpace", @"The specified size exceeds the remaining buffer space ('{0}' bytes).");
        /// <summary>Encountered invalid character '{0}'.</summary>
        internal static string @InvalidCharacterEncountered => GetResourceString("InvalidCharacterEncountered", @"Encountered invalid character '{0}'.");
        /// <summary>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</summary>
        internal static string @JsonInvalidFFFE => GetResourceString("JsonInvalidFFFE", @"Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.");
        /// <summary>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</summary>
        internal static string @JsonDateTimeOutOfRange => GetResourceString("JsonDateTimeOutOfRange", @"DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.");
        /// <summary>To write JSON arrays, use XML writer methods to write the attribute type='array' followed by methods like WriteStartElement (with the local name 'item'), WriteAttributeString, and WriteEndElement to write the JSON array items.</summary>
        internal static string @JsonWriteArrayNotSupported => GetResourceString("JsonWriteArrayNotSupported", @"To write JSON arrays, use XML writer methods to write the attribute type='array' followed by methods like WriteStartElement (with the local name 'item'), WriteAttributeString, and WriteEndElement to write the JSON array items.");
        /// <summary>This XmlDictionaryWriter implementation does not support the '{0}' method.</summary>
        internal static string @JsonMethodNotSupported => GetResourceString("JsonMethodNotSupported", @"This XmlDictionaryWriter implementation does not support the '{0}' method.");
        /// <summary>There is no open attribute.</summary>
        internal static string @JsonNoMatchingStartAttribute => GetResourceString("JsonNoMatchingStartAttribute", @"There is no open attribute.");
        /// <summary>Encountered unexpected namespace '{0}'. The namespace must be empty.</summary>
        internal static string @JsonNamespaceMustBeEmpty => GetResourceString("JsonNamespaceMustBeEmpty", @"Encountered unexpected namespace '{0}'. The namespace must be empty.");
        /// <summary>No corresponding start element is open.</summary>
        internal static string @JsonEndElementNoOpenNodes => GetResourceString("JsonEndElementNoOpenNodes", @"No corresponding start element is open.");
        /// <summary>Cannot call {0} while an attribute is being written.</summary>
        internal static string @JsonOpenAttributeMustBeClosedFirst => GetResourceString("JsonOpenAttributeMustBeClosedFirst", @"Cannot call {0} while an attribute is being written.");
        /// <summary>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</summary>
        internal static string @JsonMustSpecifyDataType => GetResourceString("JsonMustSpecifyDataType", @"You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.");
        /// <summary>Processing instructions (other than the XML declaration) are not supported.</summary>
        internal static string @JsonXmlProcessingInstructionNotSupported => GetResourceString("JsonXmlProcessingInstructionNotSupported", @"Processing instructions (other than the XML declaration) are not supported.");
        /// <summary>XML declaration can only be written at the beginning of the document.</summary>
        internal static string @JsonXmlInvalidDeclaration => GetResourceString("JsonXmlInvalidDeclaration", @"XML declaration can only be written at the beginning of the document.");
        /// <summary>The empty string is not a valid local name in JSON.</summary>
        internal static string @JsonInvalidLocalNameEmpty => GetResourceString("JsonInvalidLocalNameEmpty", @"The empty string is not a valid local name in JSON.");
        /// <summary>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</summary>
        internal static string @JsonPrefixMustBeNullOrEmpty => GetResourceString("JsonPrefixMustBeNullOrEmpty", @"Encountered unexpected prefix '{0}'. The prefix must be null or empty.");
        /// <summary>WriteStartElement must be called at least once before WriteStartAttribute may be called.</summary>
        internal static string @JsonAttributeMustHaveElement => GetResourceString("JsonAttributeMustHaveElement", @"WriteStartElement must be called at least once before WriteStartAttribute may be called.");
        /// <summary>Cannot write attribute with local name '{0}' multiple times.</summary>
        internal static string @JsonAttributeAlreadyWritten => GetResourceString("JsonAttributeAlreadyWritten", @"Cannot write attribute with local name '{0}' multiple times.");
        /// <summary>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</summary>
        internal static string @JsonServerTypeSpecifiedForInvalidDataType => GetResourceString("JsonServerTypeSpecifiedForInvalidDataType", @"Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.");
        /// <summary>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'.  ...</summary>
        internal static string @JsonUnexpectedAttributeLocalName => GetResourceString("JsonUnexpectedAttributeLocalName", @"Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.");
        /// <summary>'{0}' cannot be called while WriteState is '{1}'.</summary>
        internal static string @JsonInvalidWriteState => GetResourceString("JsonInvalidWriteState", @"'{0}' cannot be called while WriteState is '{1}'.");
        /// <summary>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</summary>
        internal static string @JsonMultipleRootElementsNotAllowedOnWriter => GetResourceString("JsonMultipleRootElementsNotAllowedOnWriter", @"This XmlDictionaryWriter implementation does not support the writing of multiple root elements.");
        /// <summary>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</summary>
        internal static string @JsonInvalidRootElementName => GetResourceString("JsonInvalidRootElementName", @"Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.");
        /// <summary>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</summary>
        internal static string @JsonNodeTypeArrayOrObjectNotSpecified => GetResourceString("JsonNodeTypeArrayOrObjectNotSpecified", @"WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.");
        /// <summary>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</summary>
        internal static string @JsonInvalidItemNameForArrayElement => GetResourceString("JsonInvalidItemNameForArrayElement", @"Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.");
        /// <summary>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</summary>
        internal static string @JsonInvalidStartElementCall => GetResourceString("JsonInvalidStartElementCall", @"WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.");
        /// <summary>Unexpected character '{0}'. '{1}' can write only whitespace characters.</summary>
        internal static string @JsonOnlyWhitespace => GetResourceString("JsonOnlyWhitespace", @"Unexpected character '{0}'. '{1}' can write only whitespace characters.");
        /// <summary>The writer is closed.</summary>
        internal static string @JsonWriterClosed => GetResourceString("JsonWriterClosed", @"The writer is closed.");
        /// <summary>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</summary>
        internal static string @JsonCannotWriteStandaloneTextAfterQuotedText => GetResourceString("JsonCannotWriteStandaloneTextAfterQuotedText", @"Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.");
        /// <summary>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</summary>
        internal static string @JsonMustUseWriteStringForWritingAttributeValues => GetResourceString("JsonMustUseWriteStringForWritingAttributeValues", @"To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.");
        /// <summary>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</summary>
        internal static string @JsonInvalidDataTypeSpecifiedForServerType => GetResourceString("JsonInvalidDataTypeSpecifiedForServerType", @"Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.");
        /// <summary>Cannot write content while an attribute is being written.</summary>
        internal static string @JsonInvalidMethodBetweenStartEndAttribute => GetResourceString("JsonInvalidMethodBetweenStartEndAttribute", @"Cannot write content while an attribute is being written.");
        /// <summary>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</summary>
        internal static string @JsonCannotWriteTextAfterNonTextAttribute => GetResourceString("JsonCannotWriteTextAfterNonTextAttribute", @"Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.");
        /// <summary>Nested arrays are not supported.</summary>
        internal static string @JsonNestedArraysNotSupported => GetResourceString("JsonNestedArraysNotSupported", @"Nested arrays are not supported.");
        /// <summary>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</summary>
        internal static string @JsonEncodingNotSupported => GetResourceString("JsonEncodingNotSupported", @"Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.");
        /// <summary>The expected encoding '{0}' does not match the actual encoding '{1}'.</summary>
        internal static string @JsonExpectedEncoding => GetResourceString("JsonExpectedEncoding", @"The expected encoding '{0}' does not match the actual encoding '{1}'.");
        /// <summary>Unexpected end of file.</summary>
        internal static string @JsonUnexpectedEndOfFile => GetResourceString("JsonUnexpectedEndOfFile", @"Unexpected end of file.");
        /// <summary>Assembly '{0}' is not found.</summary>
        internal static string @AssemblyNotFound => GetResourceString("AssemblyNotFound", @"Assembly '{0}' is not found.");
        /// <summary>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</summary>
        internal static string @ClrTypeNotFound => GetResourceString("ClrTypeNotFound", @"The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.");
        /// <summary>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</summary>
        internal static string @AttributeNotFound => GetResourceString("AttributeNotFound", @"XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</summary>
        internal static string @JsonDuplicateMemberInInput => GetResourceString("JsonDuplicateMemberInInput", @"The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</summary>
        internal static string @JsonRequiredMembersNotFound => GetResourceString("JsonRequiredMembersNotFound", @"The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.");
        /// <summary>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</summary>
        internal static string @JsonOneRequiredMemberNotFound => GetResourceString("JsonOneRequiredMemberNotFound", @"The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.");
        /// <summary>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</summary>
        internal static string @EnumTypeNotSupportedByDataContractJsonSerializer => GetResourceString("EnumTypeNotSupportedByDataContractJsonSerializer", @"DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.");
        /// <summary>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</summary>
        internal static string @KeyTypeCannotBeParsedInSimpleDictionary => GetResourceString("KeyTypeCannotBeParsedInSimpleDictionary", @"The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.");
        /// <summary>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'.</summary>
        internal static string @SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser => GetResourceString("SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser", @"Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'.");
        /// <summary>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the n ...</summary>
        internal static string @FactoryObjectContainsSelfReference => GetResourceString("FactoryObjectContainsSelfReference", @"Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.");
        /// <summary>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</summary>
        internal static string @RecursiveCollectionType => GetResourceString("RecursiveCollectionType", @"Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.");
        /// <summary>Type '{0}' is not a valid XML type.</summary>
        internal static string @UnknownXmlType => GetResourceString("UnknownXmlType", @"Type '{0}' is not a valid XML type.");
        /// <summary>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</summary>
        internal static string @DupContractInDataContractSet => GetResourceString("DupContractInDataContractSet", @"DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.");
        /// <summary>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</summary>
        internal static string @DupTypeContractInDataContractSet => GetResourceString("DupTypeContractInDataContractSet", @"DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.");
        /// <summary>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</summary>
        internal static string @GenericTypeNameMismatch => GetResourceString("GenericTypeNameMismatch", @"DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.");
        /// <summary>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</summary>
        internal static string @GenericTypeNotExportable => GetResourceString("GenericTypeNotExportable", @"Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.");
        /// <summary>Cannot export null assembly provided via '{0}' parameter.</summary>
        internal static string @CannotExportNullAssembly => GetResourceString("CannotExportNullAssembly", @"Cannot export null assembly provided via '{0}' parameter.");
        /// <summary>Cannot export null type provided via KnownTypesCollection.</summary>
        internal static string @CannotExportNullKnownType => GetResourceString("CannotExportNullKnownType", @"Cannot export null type provided via KnownTypesCollection.");
        /// <summary>Cannot export null type provided via '{0}' parameter.</summary>
        internal static string @CannotExportNullType => GetResourceString("CannotExportNullType", @"Cannot export null type provided via '{0}' parameter.");
        /// <summary>Cannot find a path to the member when generating the XPath query.</summary>
        internal static string @QueryGeneratorPathToMemberNotFound => GetResourceString("QueryGeneratorPathToMemberNotFound", @"Cannot find a path to the member when generating the XPath query.");
        /// <summary>Stream returned by IStreamProvider cannot be null.</summary>
        internal static string @XmlInvalidStream => GetResourceString("XmlInvalidStream", @"Stream returned by IStreamProvider cannot be null.");
        /// <summary>Type '{0}' has set its ISerializable assembly name to "0". "0" is an invalid assembly name. Consider using the full name of mscorlib if you would like your type to be deserialized in that assembly.</summary>
        internal static string @ISerializableAssemblyNameSetToZero => GetResourceString("ISerializableAssemblyNameSetToZero", @"Type '{0}' has set its ISerializable assembly name to ""0"". ""0"" is an invalid assembly name. Consider using the full name of mscorlib if you would like your type to be deserialized in that assembly.");
        /// <summary>Only classes can be generated as ISerializable.</summary>
        internal static string @RequiresClassDataContractToSetIsISerializable => GetResourceString("RequiresClassDataContractToSetIsISerializable", @"Only classes can be generated as ISerializable.");
        /// <summary>Type '{0}' cannot be ISerializable and have DataContractAttribute attribute.</summary>
        internal static string @ISerializableCannotHaveDataContract => GetResourceString("ISerializableCannotHaveDataContract", @"Type '{0}' cannot be ISerializable and have DataContractAttribute attribute.");
        /// <summary>The constructor with parameters (SerializationInfo, StreamingContext) is not found in ISerializable type '{0}'.</summary>
        internal static string @SerializationInfo_ConstructorNotFound => GetResourceString("SerializationInfo_ConstructorNotFound", @"The constructor with parameters (SerializationInfo, StreamingContext) is not found in ISerializable type '{0}'.");
        /// <summary>DataContractJsonSerializer does not support the setting of the FullTypeName of the object to be serialized to a value other than the default FullTypeName. Attempted to serialize object with full type name '{0}' and default full type name '{1}'.</summary>
        internal static string @ChangingFullTypeNameNotSupported => GetResourceString("ChangingFullTypeNameNotSupported", @"DataContractJsonSerializer does not support the setting of the FullTypeName of the object to be serialized to a value other than the default FullTypeName. Attempted to serialize object with full type name '{0}' and default full type name '{1}'.");
        /// <summary>Interface type '{0}' cannot be created. Consider replacing with a non-interface serializable type.</summary>
        internal static string @InterfaceTypeCannotBeCreated => GetResourceString("InterfaceTypeCannotBeCreated", @"Interface type '{0}' cannot be created. Consider replacing with a non-interface serializable type.");
        /// <summary>Array Size '{0}' is not equal to the number of elements found '{1}'.</summary>
        internal static string @ArraySizeAttributeIncorrect => GetResourceString("ArraySizeAttributeIncorrect", @"Array Size '{0}' is not equal to the number of elements found '{1}'.");
        /// <summary>Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.</summary>
        internal static string @DuplicateExtensionDataSetMethod => GetResourceString("DuplicateExtensionDataSetMethod", @"Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.");
        /// <summary>IExtensibleDataObject property setter '{1}' in type '{0}' must return void.</summary>
        internal static string @ExtensionDataSetMustReturnVoid => GetResourceString("ExtensionDataSetMustReturnVoid", @"IExtensibleDataObject property setter '{1}' in type '{0}' must return void.");
        /// <summary>IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.</summary>
        internal static string @ExtensionDataSetParameterInvalid => GetResourceString("ExtensionDataSetParameterInvalid", @"IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.");
        /// <summary>Type '{0}' does not have DataContractAttribute attribute and therefore cannot support IExtensibleDataObject.</summary>
        internal static string @OnlyDataContractTypesCanHaveExtensionData => GetResourceString("OnlyDataContractTypesCanHaveExtensionData", @"Type '{0}' does not have DataContractAttribute attribute and therefore cannot support IExtensibleDataObject.");
        /// <summary>JsonObjectDataContract.ParseJsonNumber shouldn't return a TypeCode that we're not expecting.</summary>
        internal static string @ParseJsonNumberReturnInvalidNumber => GetResourceString("ParseJsonNumberReturnInvalidNumber", @"JsonObjectDataContract.ParseJsonNumber shouldn't return a TypeCode that we're not expecting.");
        /// <summary>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</summary>
        internal static string @CouldNotReadSerializationSchema => GetResourceString("CouldNotReadSerializationSchema", @"An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.");
        /// <summary>Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.</summary>
        internal static string @MissingSchemaType => GetResourceString("MissingSchemaType", @"Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.");
        /// <summary>Method '{0}.GetSchema()' must return a schema with a valid Id.</summary>
        internal static string @InvalidReturnSchemaOnGetSchemaMethod => GetResourceString("InvalidReturnSchemaOnGetSchemaMethod", @"Method '{0}.GetSchema()' must return a schema with a valid Id.");
        /// <summary>The Message Transmission Optimization Mechanism (MTOM) message encoding is not supported on this platform.</summary>
        internal static string @PlatformNotSupported_MtomEncoding => GetResourceString("PlatformNotSupported_MtomEncoding", @"The Message Transmission Optimization Mechanism (MTOM) message encoding is not supported on this platform.");
        /// <summary>System.Runtime.Serialization.NetDataContractSerializer is not supported on this platform.</summary>
        internal static string @PlatformNotSupported_NetDataContractSerializer => GetResourceString("PlatformNotSupported_NetDataContractSerializer", @"System.Runtime.Serialization.NetDataContractSerializer is not supported on this platform.");
        /// <summary>The implementation of the function requires System.Runtime.Serialization.IDataContractSurrogate which is not supported on this platform.</summary>
        internal static string @PlatformNotSupported_IDataContractSurrogate => GetResourceString("PlatformNotSupported_IDataContractSurrogate", @"The implementation of the function requires System.Runtime.Serialization.IDataContractSurrogate which is not supported on this platform.");
        /// <summary>The implementation of the function requires System.Runtime.Serialization.SchemaImporter which is not supported on this platform.</summary>
        internal static string @PlatformNotSupported_SchemaImporter => GetResourceString("PlatformNotSupported_SchemaImporter", @"The implementation of the function requires System.Runtime.Serialization.SchemaImporter which is not supported on this platform.");
        /// <summary>Factory type '{0}' for ISerializable type '{1}' must also be ISerializable.</summary>
        internal static string @FactoryTypeNotISerializable => GetResourceString("FactoryTypeNotISerializable", @"Factory type '{0}' for ISerializable type '{1}' must also be ISerializable.");
        /// <summary>Canonicalization already started.</summary>
        internal static string @XmlCanonicalizationStarted => GetResourceString("XmlCanonicalizationStarted", @"Canonicalization already started.");
        /// <summary>Canonicalization not started.</summary>
        internal static string @XmlCanonicalizationNotStarted => GetResourceString("XmlCanonicalizationNotStarted", @"Canonicalization not started.");
        /// <summary>The combined length of the prefix and namespace must not be greater than {0}.</summary>
        internal static string @CombinedPrefixNSLength => GetResourceString("CombinedPrefixNSLength", @"The combined length of the prefix and namespace must not be greater than {0}.");
        /// <summary>The inclusive namespace prefix collection cannot contain null as one of the items.</summary>
        internal static string @InvalidInclusivePrefixListCollection => GetResourceString("InvalidInclusivePrefixListCollection", @"The inclusive namespace prefix collection cannot contain null as one of the items.");
        /// <summary>Cannot set option twice.</summary>
        internal static string @CannotSetTwice => GetResourceString("CannotSetTwice", @"Cannot set option twice.");
        /// <summary>'{0}' must be greater than 0.</summary>
        internal static string @MustBeGreaterThanZero => GetResourceString("MustBeGreaterThanZero", @"'{0}' must be greater than 0.");
        /// <summary>{0} The class cannot be deserialized.</summary>
        internal static string @ReadOnlyClassDeserialization => GetResourceString("ReadOnlyClassDeserialization", @"{0} The class cannot be deserialized.");
        /// <summary>Collection type '{0}' cannot be deserialized since it</summary>
        internal static string @ReadOnlyCollectionDeserialization => GetResourceString("ReadOnlyCollectionDeserialization", @"Collection type '{0}' cannot be deserialized since it");
        /// <summary>Unknown Type for null value</summary>
        internal static string @UnknownNullType => GetResourceString("UnknownNullType", @"Unknown Type for null value");
        /// <summary>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</summary>
        internal static string @AmbiguousReferencedTypes1 => GetResourceString("AmbiguousReferencedTypes1", @"List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}");
        /// <summary>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</summary>
        internal static string @AmbiguousReferencedTypes3 => GetResourceString("AmbiguousReferencedTypes3", @"List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}");
        /// <summary>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</summary>
        internal static string @AmbiguousReferencedCollectionTypes1 => GetResourceString("AmbiguousReferencedCollectionTypes1", @"List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}");
        /// <summary>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</summary>
        internal static string @AmbiguousReferencedCollectionTypes3 => GetResourceString("AmbiguousReferencedCollectionTypes3", @"List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}");
        /// <summary>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</summary>
        internal static string @ReferencedCollectionTypesCannotContainNull => GetResourceString("ReferencedCollectionTypesCannotContainNull", @"ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.");
        /// <summary>(matching)</summary>
        internal static string @ReferencedTypeMatchingMessage => GetResourceString("ReferencedTypeMatchingMessage", @"(matching)");
        /// <summary>(not matching)</summary>
        internal static string @ReferencedTypeNotMatchingMessage => GetResourceString("ReferencedTypeNotMatchingMessage", @"(not matching)");
        /// <summary>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</summary>
        internal static string @ReferencedTypesCannotContainNull => GetResourceString("ReferencedTypesCannotContainNull", @"ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.");
        /// <summary>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.</summary>
        internal static string @SurrogatesWithGetOnlyCollectionsNotSupported => GetResourceString("SurrogatesWithGetOnlyCollectionsNotSupported", @"Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.");
        /// <summary>The element cannot have 'abstract' set to 'true'.</summary>
        internal static string @AbstractElementNotSupported => GetResourceString("AbstractElementNotSupported", @"The element cannot have 'abstract' set to 'true'.");
        /// <summary>The type cannot have 'abstract' set to 'true'.</summary>
        internal static string @AbstractTypeNotSupported => GetResourceString("AbstractTypeNotSupported", @"The type cannot have 'abstract' set to 'true'.");
        /// <summary>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</summary>
        internal static string @AnnotationAttributeNotFound => GetResourceString("AnnotationAttributeNotFound", @"Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.");
        /// <summary>Anonymous type in element '{0}' from namespace '{1}' is not supported.</summary>
        internal static string @AnonymousTypeNotSupported => GetResourceString("AnonymousTypeNotSupported", @"Anonymous type in element '{0}' from namespace '{1}' is not supported.");
        /// <summary>'anyAttribute' is not supported.</summary>
        internal static string @AnyAttributeNotSupported => GetResourceString("AnyAttributeNotSupported", @"'anyAttribute' is not supported.");
        /// <summary>Form for element '{0}' must be qualified.</summary>
        internal static string @ArrayItemFormMustBe => GetResourceString("ArrayItemFormMustBe", @"Form for element '{0}' must be qualified.");
        /// <summary>Array type '{0}' in namespace '{1}' cannot be imported. {2}</summary>
        internal static string @ArrayTypeCannotBeImported => GetResourceString("ArrayTypeCannotBeImported", @"Array type '{0}' in namespace '{1}' cannot be imported. {2}");
        /// <summary>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</summary>
        internal static string @BaseTypeNotISerializable => GetResourceString("BaseTypeNotISerializable", @"One of its base types, '{0}' from namespace '{1}' is not ISerializable.");
        /// <summary>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</summary>
        internal static string @CannotComputeUniqueName => GetResourceString("CannotComputeUniqueName", @"A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.");
        /// <summary>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</summary>
        internal static string @CannotHaveDuplicateAttributeNames => GetResourceString("CannotHaveDuplicateAttributeNames", @"The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.");
        /// <summary>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</summary>
        internal static string @CannotHaveDuplicateElementNames => GetResourceString("CannotHaveDuplicateElementNames", @"The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.");
        /// <summary>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</summary>
        internal static string @CannotImportInvalidSchemas => GetResourceString("CannotImportInvalidSchemas", @"Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.");
        /// <summary>Cannot import type for null XmlQualifiedName specified via parameter.</summary>
        internal static string @CannotImportNullDataContractName => GetResourceString("CannotImportNullDataContractName", @"Cannot import type for null XmlQualifiedName specified via parameter.");
        /// <summary>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</summary>
        internal static string @CannotImportNullSchema => GetResourceString("CannotImportNullSchema", @"Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.");
        /// <summary>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</summary>
        internal static string @ComplexTypeRestrictionNotSupported => GetResourceString("ComplexTypeRestrictionNotSupported", @"An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.");
        /// <summary>Default value on element '{0}' is not supported.</summary>
        internal static string @DefaultOnElementNotSupported => GetResourceString("DefaultOnElementNotSupported", @"Default value on element '{0}' is not supported.");
        /// <summary>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</summary>
        internal static string @DerivedTypeNotISerializable => GetResourceString("DerivedTypeNotISerializable", @"It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.");
        /// <summary>'maxOccurs' on element '{0}' must be 1.</summary>
        internal static string @ElementMaxOccursMustBe => GetResourceString("ElementMaxOccursMustBe", @"'maxOccurs' on element '{0}' must be 1.");
        /// <summary>'minOccurs' on element '{0}' must be 0 or 1.</summary>
        internal static string @ElementMinOccursMustBe => GetResourceString("ElementMinOccursMustBe", @"'minOccurs' on element '{0}' must be 0 or 1.");
        /// <summary>Ref to element '{0}' in '{1}' namespace is not supported.</summary>
        internal static string @ElementRefOnLocalElementNotSupported => GetResourceString("ElementRefOnLocalElementNotSupported", @"Ref to element '{0}' in '{1}' namespace is not supported.");
        /// <summary>Enumeration facets without 'value' are not supported.</summary>
        internal static string @EnumEnumerationFacetsMustHaveValue => GetResourceString("EnumEnumerationFacetsMustHaveValue", @"Enumeration facets without 'value' are not supported.");
        /// <summary>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</summary>
        internal static string @EnumListInAnonymousTypeNotSupported => GetResourceString("EnumListInAnonymousTypeNotSupported", @"Anonymous type with <list> cannot be used to create Flags enumeration because it is not a valid enum type.");
        /// <summary>Simple type list must contain an anonymous type specifying enumeration facets.</summary>
        internal static string @EnumListMustContainAnonymousType => GetResourceString("EnumListMustContainAnonymousType", @"Simple type list must contain an anonymous type specifying enumeration facets.");
        /// <summary>Facets other than enumeration facets are not supported.</summary>
        internal static string @EnumOnlyEnumerationFacetsSupported => GetResourceString("EnumOnlyEnumerationFacetsSupported", @"Facets other than enumeration facets are not supported.");
        /// <summary>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</summary>
        internal static string @EnumRestrictionInvalid => GetResourceString("EnumRestrictionInvalid", @"Anonymous type with <restriction> cannot be used to create Flags enumeration because it is not a valid enum type.");
        /// <summary>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</summary>
        internal static string @EnumTypeCannotBeImported => GetResourceString("EnumTypeCannotBeImported", @"Enum type '{0}' in namespace '{1}' cannot be imported. {2}");
        /// <summary>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</summary>
        internal static string @EnumUnionInAnonymousTypeNotSupported => GetResourceString("EnumUnionInAnonymousTypeNotSupported", @"Anonymous type with <union>. cannot be used to create Flags enumeration because it is not a valid enum type.");
        /// <summary>Fixed value on element '{0}' is not supported.</summary>
        internal static string @FixedOnElementNotSupported => GetResourceString("FixedOnElementNotSupported", @"Fixed value on element '{0}' is not supported.");
        /// <summary>Form on element '{0}' must be qualified.</summary>
        internal static string @FormMustBeQualified => GetResourceString("FormMustBeQualified", @"Form on element '{0}' must be qualified.");
        /// <summary>Annotation for generic type '{0}' did not have attribute '{1}'.</summary>
        internal static string @GenericAnnotationAttributeNotFound => GetResourceString("GenericAnnotationAttributeNotFound", @"Annotation for generic type '{0}' did not have attribute '{1}'.");
        /// <summary>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</summary>
        internal static string @GenericAnnotationForNestedLevelMustBeIncreasing => GetResourceString("GenericAnnotationForNestedLevelMustBeIncreasing", @"Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.");
        /// <summary>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</summary>
        internal static string @GenericAnnotationHasInvalidAttributeValue => GetResourceString("GenericAnnotationHasInvalidAttributeValue", @"Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.");
        /// <summary>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</summary>
        internal static string @GenericAnnotationHasInvalidElement => GetResourceString("GenericAnnotationHasInvalidElement", @"Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.");
        /// <summary>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</summary>
        internal static string @InvalidAnnotationExpectingText => GetResourceString("InvalidAnnotationExpectingText", @"Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.");
        /// <summary>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</summary>
        internal static string @InvalidClassDerivation => GetResourceString("InvalidClassDerivation", @"Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.");
        /// <summary>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</summary>
        internal static string @InvalidEmitDefaultAnnotation => GetResourceString("InvalidEmitDefaultAnnotation", @"Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.");
        /// <summary>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</summary>
        internal static string @InvalidISerializableDerivation => GetResourceString("InvalidISerializableDerivation", @"Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.");
        /// <summary>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</summary>
        internal static string @InvalidKeyValueType => GetResourceString("InvalidKeyValueType", @"It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.");
        /// <summary>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</summary>
        internal static string @InvalidKeyValueTypeNamespace => GetResourceString("InvalidKeyValueTypeNamespace", @"It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.");
        /// <summary>'{0}' is an invalid value for IsDictionary annotation. {1}</summary>
        internal static string @IsDictionaryFormattedIncorrectly => GetResourceString("IsDictionaryFormattedIncorrectly", @"'{0}' is an invalid value for IsDictionary annotation. {1}");
        /// <summary>'{0}' is an invalid value for IsValueType annotation. {1}</summary>
        internal static string @IsValueTypeFormattedIncorrectly => GetResourceString("IsValueTypeFormattedIncorrectly", @"'{0}' is an invalid value for IsValueType annotation. {1}");
        /// <summary>Its root sequence contains more than one particle.</summary>
        internal static string @ISerializableContainsMoreThanOneItems => GetResourceString("ISerializableContainsMoreThanOneItems", @"Its root sequence contains more than one particle.");
        /// <summary>Derived ISerializable types cannot contain any particles.</summary>
        internal static string @ISerializableDerivedContainsOneOrMoreItems => GetResourceString("ISerializableDerivedContainsOneOrMoreItems", @"Derived ISerializable types cannot contain any particles.");
        /// <summary>It does not contain root sequence with a wildcard element &lt;any&gt;.</summary>
        internal static string @ISerializableDoesNotContainAny => GetResourceString("ISerializableDoesNotContainAny", @"It does not contain root sequence with a wildcard element <any>.");
        /// <summary>It does not reference attribute '{0}' from namespace '{1}'.</summary>
        internal static string @ISerializableMustRefFactoryTypeAttribute => GetResourceString("ISerializableMustRefFactoryTypeAttribute", @"It does not reference attribute '{0}' from namespace '{1}'.");
        /// <summary>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</summary>
        internal static string @ISerializableTypeCannotBeImported => GetResourceString("ISerializableTypeCannotBeImported", @"ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'");
        /// <summary>'maxOccurs' on the wildcard element must be '{0}'.</summary>
        internal static string @ISerializableWildcardMaxOccursMustBe => GetResourceString("ISerializableWildcardMaxOccursMustBe", @"'maxOccurs' on the wildcard element must be '{0}'.");
        /// <summary>'minOccurs' on the wildcard element must be '{0}'.</summary>
        internal static string @ISerializableWildcardMinOccursMustBe => GetResourceString("ISerializableWildcardMinOccursMustBe", @"'minOccurs' on the wildcard element must be '{0}'.");
        /// <summary>Namespace on the wildcard element must be '{0}'.</summary>
        internal static string @ISerializableWildcardNamespaceInvalid => GetResourceString("ISerializableWildcardNamespaceInvalid", @"Namespace on the wildcard element must be '{0}'.");
        /// <summary>ProcessContents on the wildcard element must be '{0}'.</summary>
        internal static string @ISerializableWildcardProcessContentsInvalid => GetResourceString("ISerializableWildcardProcessContentsInvalid", @"ProcessContents on the wildcard element must be '{0}'.");
        /// <summary>Complex type with mixed content is not supported.</summary>
        internal static string @MixedContentNotSupported => GetResourceString("MixedContentNotSupported", @"Complex type with mixed content is not supported.");
        /// <summary>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</summary>
        internal static string @MustContainOnlyLocalElements => GetResourceString("MustContainOnlyLocalElements", @"The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.");
        /// <summary>Redefine is not supported.</summary>
        internal static string @RedefineNotSupported => GetResourceString("RedefineNotSupported", @"Redefine is not supported.");
        /// <summary>The root particle must be a sequence.</summary>
        internal static string @RootParticleMustBeSequence => GetResourceString("RootParticleMustBeSequence", @"The root particle must be a sequence.");
        /// <summary>'maxOccurs' on the root sequence must be 1.</summary>
        internal static string @RootSequenceMaxOccursMustBe => GetResourceString("RootSequenceMaxOccursMustBe", @"'maxOccurs' on the root sequence must be 1.");
        /// <summary>'minOccurs' on the root sequence must be 1.</summary>
        internal static string @RootSequenceMustBeRequired => GetResourceString("RootSequenceMustBeRequired", @"'minOccurs' on the root sequence must be 1.");
        /// <summary>Complex types with simple content extension are not supported.</summary>
        internal static string @SimpleContentNotSupported => GetResourceString("SimpleContentNotSupported", @"Complex types with simple content extension are not supported.");
        /// <summary>Simple type restriction must specify a base type.</summary>
        internal static string @SimpleTypeRestrictionDoesNotSpecifyBase => GetResourceString("SimpleTypeRestrictionDoesNotSpecifyBase", @"Simple type restriction must specify a base type.");
        /// <summary>Simple types with &lt;union&gt; content are not supported.</summary>
        internal static string @SimpleTypeUnionNotSupported => GetResourceString("SimpleTypeUnionNotSupported", @"Simple types with <union> content are not supported.");
        /// <summary>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</summary>
        internal static string @SpecifiedTypeNotFoundInSchema => GetResourceString("SpecifiedTypeNotFoundInSchema", @"Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.");
        /// <summary>Substitution group on element '{0}' is not supported.</summary>
        internal static string @SubstitutionGroupOnElementNotSupported => GetResourceString("SubstitutionGroupOnElementNotSupported", @"Substitution group on element '{0}' is not supported.");
        /// <summary>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</summary>
        internal static string @TopLevelElementRepresentsDifferentType => GetResourceString("TopLevelElementRepresentsDifferentType", @"The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.");
        /// <summary>Type '{0}' in namespace '{1}' cannot be imported. {2}</summary>
        internal static string @TypeCannotBeImported => GetResourceString("TypeCannotBeImported", @"Type '{0}' in namespace '{1}' cannot be imported. {2}");
        /// <summary>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</summary>
        internal static string @TypeCannotBeImportedHowToFix => GetResourceString("TypeCannotBeImportedHowToFix", @"{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.");
        /// <summary>Attributes must be optional and from namespace '{0}'.</summary>
        internal static string @TypeShouldNotContainAttributes => GetResourceString("TypeShouldNotContainAttributes", @"Attributes must be optional and from namespace '{0}'.");
 
    }
}
